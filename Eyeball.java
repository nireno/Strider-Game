/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package game;

/**
 *
 * @author Who
 */
public class Eyeball extends Enemy {
private boolean landed;
	public Eyeball(float xPos, float yPos, Game game, BricksManager bricksMgr, RibbonsManager ribbonsMgr)
	{
		super(xPos, yPos, game);
		sprite = new Sprite((int) xPos, (int) yPos, game.getWidth(), game.getHeight(), game.getImgLdr(), "Eyeball");
		sprite.setActive(true);
		colBox = sprite.getMyRectangle();
//		colBox.grow(-sprite.getWidth() / 4, -sprite.getHeight() / 6);//resize to match the sprite
		maxXVel = 2;
		xVel = maxXVel;
		initHP(100);
		state = "roaming";
		dmgPushMag = 3;
		attackVal = 5;
	}

	public void die()
	{
		//sprite.setActive(false);
		sprite.setImage("EyeballDie");
		sprite.playImgSeq(30, 1);
		state = "dying";
		//xVel = yVel = 0;
		System.out.println("eyeball dead");
	}

	public void update()
	{
		if(state.matches("dying")){
                    if (sprite.imgSeqEnded())
                    {
                            xVel = 0;
                            sprite.setImage("tombstone");
                            isDead =true;
                    }
		}
		if (state.matches("roaming"))
		{
			if (!sprite.getIsLooping())
			{
				sprite.loopImage(60, 2);
			}
			//turn around when hits a brick
			if (bOnFloor)
			{
				yVel -= 10;
				bOnFloor = false;
			}
		}
		if (willHitBrick())
		{
			xVel *= -1;
			if (state.matches("takingDamage"))
			{
				xVel = 0;
			}
			else
			{
				if (isFacingRight)
				{
					isFacingRight = false;
				} else
				{
					isFacingRight = true;
				}
			}
		}
//        if(!state.matches("takingDamage"))
		setXPos(xPos + xVel);//*game.getDeltaTime()/1000);
//        else
		if (takeDmgTime <= 0 && !state.matches("dying"))
		{
			state = "roaming";
			if (isFacingRight)
			{
				xVel = maxXVel;
			} else
			{
				xVel = -maxXVel;
			}
		} else
		{
			takeDmgTime -= game.getDeltaTime();
		}
		if (sprite.getXPosn() < -sprite.getWidth() || sprite.getXPosn() > game.getWidth())
		{
			sprite.setActive(false);
		} else
		{
			if (!state.matches("dying"))
			{
				sprite.setActive(true);
			}
		}
		processVertMotion();
		setYPos(yPos + yVel);
		//if enemy collides with the player then damage the player
		if (colBox.intersects(game.getPlayer().getColBox()) && !state.matches("dying"))
		{
			game.getPlayer().takeDamage(attackVal, this);
		}
		sprite.updateSprite();
//		System.out.println("Eyeball state "+state);
	}
	@Override
	protected void processVertMotion()
	{
		//apply gravity
		yVel += game.getGravity();//*game.getDeltaTime();
		if (yVel > maxYVel)
		{
			yVel = maxYVel;
		}
		if (yVel < 0)//if sprite is moving up. TODO: check multiple collision points like when falling
		{
			//determine if yVel needs to be reduced to avoid entering a brick from below
			yVel = bricksMgr.checkBrickBase((int) xPos + (sprite.getWidth() / 2), (int) (yPos + yVel), (int) -yVel);//make yVel +ve for the 3rd param.
			yVel = -yVel;//checkBrickBase works with a positive 3rd param so we have to change it back to -ve here.
		} else
		{
			if (yVel > 0)//if falling
			{
				//determine if yVel needs to be increased to avoid entering the floor
				yVel = Math.min(bricksMgr.checkBrickTop((int) (xPos + (sprite.getWidth() * 0.75)), (int) (yPos + sprite.getHeight() + yVel), (int) yVel),
						bricksMgr.checkBrickTop((int) (xPos + (sprite.getWidth() * 0.25)), (int) (yPos + sprite.getHeight() + yVel), (int) yVel));
				//if Actor hits the floor
				if (yVel == 0 && !bOnFloor)
				{
					if (xVel != 0&&!state.matches("dying"))
					{
						state = "roaming";
						//set walking sprite here
					} else if(!state.matches("dying"))
					{
						state = "stopped";
						//set stopped sprite here
					}
					bOnFloor = true;
				}
			}
		}
	}//end processVertMotion;

	@Override
	public void takeDamage(int damage, Actor damager)
	{
		super.takeDamage(damage, damager);
//		yVel = 0;//remove the y component of the damage push vector generated by takeDamage
		takeDmgTime = 500;

	}
	@Override
	public void setIsWeakened(boolean isWeak)
	{
		super.setIsWeakened(isWeak);
		if(isWeak)
		{
			takeDmgMultiplier = 2;
			maxXVel /=2;
			cycleTime*=2;//slow down animation to match new xVel
			attackVal/=2;
		}
		else
		{
			//TODO: need to create default value variables to reset xVel etc if not weak;\
		}
	}
}
